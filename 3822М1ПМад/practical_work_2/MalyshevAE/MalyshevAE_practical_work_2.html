{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Практическая работа 2 «Перенос обучения с использованием MXNet или PyTorch»"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Требования\n",
    "1. Загрузка данных. Загрузка реализована при выполнении предыдущей работы, поэтому отдельно не оценивается.\n",
    "2. Построение архитектуры сверточной сети. Построение архитектуры сверточной сети (загрузка и модификация последних слоев). Требуется вывести информацию об архитектуре, опционально выполнить визуализацию сети.\n",
    "3. Обучение и тестирование модели. Необходимо вывести информацию о способе инициализации весов сети и параметрах алгоритма обучения. Необходимо обеспечить вывод точности классификации на тестовой выборке.\n",
    "4. Представление результатов. Этап с обучением и тестированием следует выполнить для 4 моделей и с 2 разными конфигурациями (гиперпараметрами/модификациями слоев). Для множества выбранных моделей, обученных для решения исходной задачи необходимо построить сравнительную столбчатую диаграмму точностей: по горизонтали — модель и тип эксперимента (кратко указать параметры), по вертикали — точность. Также следует добавить на график эксперимент из первой практической работы.\n",
    "5. В конце необходимо вывести информацию о модели, для которой получены лучшие результаты решения задачи: название исходной модели, модифицированные слои, тип эксперимента по переносу обучения, параметры обучения (алгоритм оптимизации и его параметры, способ инициализации весов), полученная точность классификации на тестовой выборке."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Загрузка библиотек"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torchvision.transforms as transforms\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import os\n",
    "import time\n",
    "from matplotlib import pyplot as plot\n",
    "import torch\n",
    "import torchvision\n",
    "import seaborn as sns\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Установка параметров"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "root_for_dataset = os.getcwd()\n",
    "learning_rate = 0.001\n",
    "num_epochs = 2\n",
    "size_of_set = 128\n",
    "device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n",
    "criterion = torch.nn.CrossEntropyLoss()\n",
    "classes = ('plane', 'car', 'bird', 'cat',\n",
    "           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')\n",
    "percentage_accuracy = []"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Функции для загрузки данных, обучении модели, тестировании модели"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def load_data(transform):\n",
    "    trainset = torchvision.datasets.CIFAR10(root=root_for_dataset, train=True,\n",
    "                                        download=True, transform=transform)\n",
    "    trainloader = torch.utils.data.DataLoader(trainset, batch_size=size_of_set,\n",
    "                                          shuffle=True, num_workers=2)\n",
    "    testset = torchvision.datasets.CIFAR10(root=root_for_dataset, train=False,\n",
    "                                       download=True, transform=transform)\n",
    "    testloader = torch.utils.data.DataLoader(testset, batch_size=size_of_set,\n",
    "                                         shuffle=False, num_workers=2)\n",
    "    return trainloader, testloader\n",
    "\n",
    "def train_network(model, trainloader, optimizer):\n",
    "        for epoch in range(num_epochs):\n",
    "            start_time = time.time()\n",
    "            running_loss = 0.0\n",
    "            for i, data in enumerate(trainloader, 0):\n",
    "                inputs, labels = data[0].to(device), data[1].to(device)\n",
    "\n",
    "                optimizer.zero_grad()\n",
    "\n",
    "                outputs = model(inputs)\n",
    "                loss = criterion(outputs, labels)\n",
    "                loss.backward()\n",
    "                optimizer.step()\n",
    "\n",
    "                running_loss += loss.item()\n",
    "                if i % 100 == 99:\n",
    "                    print('[%d, %5d] loss: %.3f' %\n",
    "                            (epoch + 1, i + 1, running_loss / 100))\n",
    "                    running_loss = 0.0\n",
    "            epoch_time = time.time() - start_time\n",
    "            print('Epoch %d took %.2f seconds' % (epoch + 1, epoch_time))\n",
    "        print('Finished training')\n",
    "\n",
    "def test_network(testloader, model):\n",
    "    correct = 0\n",
    "    total = 0\n",
    "    with torch.no_grad():\n",
    "        for data in testloader:\n",
    "            images, labels = data[0].to(device), data[1].to(device)\n",
    "            outputs = model(images)\n",
    "            _, predicted = torch.max(outputs.data, 1)\n",
    "            total += labels.size(0)\n",
    "            correct += (predicted == labels).sum().item()\n",
    "    print('Accuracy of the network on the 10000 test images: %.2f %%' % (\n",
    "    100 * correct / total))\n",
    "    return 100 * correct / total\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Функции для обучения последних слоёв сети, для полного обучения сети "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def change_last_layer_unfreezing_parameters(model, updated_layer):\n",
    "  if hasattr(model, 'fc'):\n",
    "        model.fc = updated_layer\n",
    "  elif hasattr(model, 'classifier'):\n",
    "        model.classifier = updated_layer\n",
    "\n",
    "  optimizer = optim.Adam(model.parameters(), lr = learning_rate)\n",
    "\n",
    "  return model, optimizer\n",
    "\n",
    "def change_last_layer_freezing_parameters(model, updated_layer):\n",
    "  for param in model.parameters():\n",
    "    param.requires_grad = False\n",
    "  if hasattr(model, 'fc'):\n",
    "        model.fc = updated_layer\n",
    "        optimizer = optim.Adam(model.fc.parameters(), lr = learning_rate)\n",
    "  elif hasattr(model, 'classifier'):\n",
    "        model.classifier = updated_layer\n",
    "        optimizer = optim.Adam(model.classifier.parameters(), lr = learning_rate)\n",
    "\n",
    "  return model, optimizer\n",
    "     "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Модель ResNet18"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "c:\\Users\\User\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\torchvision\\models\\_utils.py:135: UserWarning: Using 'weights' as positional parameter(s) is deprecated since 0.13 and may be removed in the future. Please use keyword parameter(s) instead.\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Files already downloaded and verified\n",
      "Files already downloaded and verified\n",
      "ResNet(\n",
      "  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)\n",
      "  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "  (relu): ReLU(inplace=True)\n",
      "  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)\n",
      "  (layer1): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (layer2): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (downsample): Sequential(\n",
      "        (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      )\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (layer3): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (downsample): Sequential(\n",
      "        (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      )\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (layer4): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (downsample): Sequential(\n",
      "        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      )\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))\n",
      "  (fc): Linear(in_features=512, out_features=10, bias=True)\n",
      ")\n",
      "[1,   100] loss: 0.723\n",
      "[1,   200] loss: 0.498\n",
      "[1,   300] loss: 0.428\n",
      "Epoch 1 took 180.95 seconds\n",
      "[2,   100] loss: 0.271\n",
      "[2,   200] loss: 0.288\n",
      "[2,   300] loss: 0.286\n",
      "Epoch 2 took 172.96 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 89.04 %\n"
     ]
    }
   ],
   "source": [
    "# ResNet18 unfreezing parameters\n",
    "weights = torchvision.models.ResNet18_Weights.DEFAULT\n",
    "model = torchvision.models.resnet18(weights)\n",
    "transforms = weights.transforms()\n",
    "trainloader, testloader = load_data(transforms)\n",
    "layers = nn.Linear(model.fc.in_features, len(classes))\n",
    "\n",
    "updated_model, optimizer = change_last_layer_unfreezing_parameters(model, layers)\n",
    "print(updated_model)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1,   100] loss: 1.380\n",
      "[1,   200] loss: 0.915\n",
      "[1,   300] loss: 0.809\n",
      "Epoch 1 took 122.92 seconds\n",
      "[2,   100] loss: 0.718\n",
      "[2,   200] loss: 0.699\n",
      "[2,   300] loss: 0.706\n",
      "Epoch 2 took 124.37 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 76.70 %\n"
     ]
    }
   ],
   "source": [
    "# ResNet18 freezing parameters\n",
    "model = torchvision.models.resnet18(weights)\n",
    "updated_model, optimizer = change_last_layer_freezing_parameters(model, layers)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Модель ResNet34"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Downloading: \"https://download.pytorch.org/models/resnet34-b627a593.pth\" to C:\\Users\\User/.cache\\torch\\hub\\checkpoints\\resnet34-b627a593.pth\n",
      "100%|██████████| 83.3M/83.3M [01:02<00:00, 1.40MB/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Files already downloaded and verified\n",
      "Files already downloaded and verified\n",
      "ResNet(\n",
      "  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)\n",
      "  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "  (relu): ReLU(inplace=True)\n",
      "  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)\n",
      "  (layer1): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (2): BasicBlock(\n",
      "      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (layer2): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (downsample): Sequential(\n",
      "        (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "        (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      )\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (2): BasicBlock(\n",
      "      (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (3): BasicBlock(\n",
      "      (conv1): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (layer3): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (downsample): Sequential(\n",
      "        (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "        (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      )\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (2): BasicBlock(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (3): BasicBlock(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (4): BasicBlock(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (5): BasicBlock(\n",
      "      (conv1): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (layer4): Sequential(\n",
      "    (0): BasicBlock(\n",
      "      (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (downsample): Sequential(\n",
      "        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      )\n",
      "    )\n",
      "    (1): BasicBlock(\n",
      "      (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "    (2): BasicBlock(\n",
      "      (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "      (relu): ReLU(inplace=True)\n",
      "      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)\n",
      "      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    )\n",
      "  )\n",
      "  (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))\n",
      "  (fc): Linear(in_features=512, out_features=10, bias=True)\n",
      ")\n",
      "[1,   100] loss: 0.816\n",
      "[1,   200] loss: 0.548\n",
      "[1,   300] loss: 0.462\n",
      "Epoch 1 took 274.62 seconds\n",
      "[2,   100] loss: 0.323\n",
      "[2,   200] loss: 0.341\n",
      "[2,   300] loss: 0.304\n",
      "Epoch 2 took 264.51 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 89.06 %\n"
     ]
    }
   ],
   "source": [
    "# GoogleNet unfreezing parameters\n",
    "weights = torchvision.models.ResNet34_Weights.DEFAULT\n",
    "model = torchvision.models.resnet34(weights)\n",
    "transforms = weights.transforms()\n",
    "trainloader, testloader = load_data(transforms)\n",
    "layers = nn.Linear(model.fc.in_features, len(classes))\n",
    "updated_model, optimizer = change_last_layer_unfreezing_parameters(model, layers)\n",
    "updated_model.to(device)\n",
    "print(updated_model)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1,   100] loss: 1.255\n",
      "[1,   200] loss: 0.845\n",
      "[1,   300] loss: 0.743\n",
      "Epoch 1 took 124.61 seconds\n",
      "[2,   100] loss: 0.667\n",
      "[2,   200] loss: 0.651\n",
      "[2,   300] loss: 0.649\n",
      "Epoch 2 took 125.27 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 77.91 %\n"
     ]
    }
   ],
   "source": [
    "# GoogleNet freezing parameters\n",
    "model = torchvision.models.resnet34(weights)\n",
    "updated_model, optimizer = change_last_layer_freezing_parameters(model, layers)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Модель ShuffleNet_v2_x0_5"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Files already downloaded and verified\n",
      "Files already downloaded and verified\n",
      "ShuffleNetV2(\n",
      "  (conv1): Sequential(\n",
      "    (0): Conv2d(3, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "    (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    (2): ReLU(inplace=True)\n",
      "  )\n",
      "  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)\n",
      "  (stage2): Sequential(\n",
      "    (0): InvertedResidual(\n",
      "      (branch1): Sequential(\n",
      "        (0): Conv2d(24, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=24, bias=False)\n",
      "        (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (3): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (4): ReLU(inplace=True)\n",
      "      )\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(24, 24, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=24, bias=False)\n",
      "        (4): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (1): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(24, 24, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=24, bias=False)\n",
      "        (4): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (2): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(24, 24, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=24, bias=False)\n",
      "        (4): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (3): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(24, 24, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=24, bias=False)\n",
      "        (4): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(24, 24, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(24, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "  )\n",
      "  (stage3): Sequential(\n",
      "    (0): InvertedResidual(\n",
      "      (branch1): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=48, bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (3): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (4): ReLU(inplace=True)\n",
      "      )\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (1): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (2): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (3): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (4): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (5): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (6): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (7): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(48, 48, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=48, bias=False)\n",
      "        (4): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "  )\n",
      "  (stage4): Sequential(\n",
      "    (0): InvertedResidual(\n",
      "      (branch1): Sequential(\n",
      "        (0): Conv2d(96, 96, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=96, bias=False)\n",
      "        (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (3): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (4): ReLU(inplace=True)\n",
      "      )\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(96, 96, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=96, bias=False)\n",
      "        (4): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (1): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=96, bias=False)\n",
      "        (4): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (2): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=96, bias=False)\n",
      "        (4): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (3): InvertedResidual(\n",
      "      (branch1): Sequential()\n",
      "      (branch2): Sequential(\n",
      "        (0): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (1): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (2): ReLU(inplace=True)\n",
      "        (3): Conv2d(96, 96, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=96, bias=False)\n",
      "        (4): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (5): Conv2d(96, 96, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "        (6): BatchNorm2d(96, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        (7): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "  )\n",
      "  (conv5): Sequential(\n",
      "    (0): Conv2d(192, 1024, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "    (1): BatchNorm2d(1024, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    (2): ReLU(inplace=True)\n",
      "  )\n",
      "  (fc): Linear(in_features=1024, out_features=10, bias=True)\n",
      ")\n",
      "[1,   100] loss: 1.282\n",
      "[1,   200] loss: 0.592\n",
      "[1,   300] loss: 0.492\n",
      "Epoch 1 took 124.97 seconds\n",
      "[2,   100] loss: 0.363\n",
      "[2,   200] loss: 0.352\n",
      "[2,   300] loss: 0.341\n",
      "Epoch 2 took 124.42 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 86.92 %\n"
     ]
    }
   ],
   "source": [
    "# shufflenet_v2_x0_5 unfreezing parameters\n",
    "weights = torchvision.models.ShuffleNet_V2_X0_5_Weights.DEFAULT\n",
    "model = torchvision.models.shufflenet_v2_x0_5(weights)\n",
    "transforms = weights.transforms()\n",
    "trainloader, testloader = load_data(transforms)\n",
    "layers = nn.Linear(model.fc.in_features, len(classes))\n",
    "\n",
    "updated_model, optimizer = change_last_layer_unfreezing_parameters(model, layers)\n",
    "print(updated_model)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1,   100] loss: 1.946\n",
      "[1,   200] loss: 1.738\n",
      "[1,   300] loss: 1.569\n",
      "Epoch 1 took 124.27 seconds\n",
      "[2,   100] loss: 1.352\n",
      "[2,   200] loss: 1.277\n",
      "[2,   300] loss: 1.208\n",
      "Epoch 2 took 124.06 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 70.10 %\n"
     ]
    }
   ],
   "source": [
    "# shufflenet_v2_x0_5 freezing parameters\n",
    "model = torchvision.models.shufflenet_v2_x0_5(weights)\n",
    "updated_model, optimizer = change_last_layer_freezing_parameters(model, layers)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Модель RegNet_y_400mf"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Files already downloaded and verified\n",
      "Files already downloaded and verified\n",
      "RegNet(\n",
      "  (stem): SimpleStemIN(\n",
      "    (0): Conv2d(3, 32, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)\n",
      "    (1): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "    (2): ReLU(inplace=True)\n",
      "  )\n",
      "  (trunk_output): Sequential(\n",
      "    (block1): AnyStage(\n",
      "      (block1-0): ResBottleneckBlock(\n",
      "        (proj): Conv2dNormActivation(\n",
      "          (0): Conv2d(32, 48, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "          (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(32, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(48, 48, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=6, bias=False)\n",
      "            (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(48, 8, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(8, 48, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(48, 48, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(48, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (block2): AnyStage(\n",
      "      (block2-0): ResBottleneckBlock(\n",
      "        (proj): Conv2dNormActivation(\n",
      "          (0): Conv2d(48, 104, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "          (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(48, 104, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=13, bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(104, 12, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(12, 104, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block2-1): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=13, bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(104, 26, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(26, 104, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block2-2): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=13, bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(104, 26, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(26, 104, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 104, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(104, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (block3): AnyStage(\n",
      "      (block3-0): ResBottleneckBlock(\n",
      "        (proj): Conv2dNormActivation(\n",
      "          (0): Conv2d(104, 208, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "          (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(104, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=26, bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(208, 26, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(26, 208, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block3-1): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=26, bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(208, 52, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(52, 208, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block3-2): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=26, bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(208, 52, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(52, 208, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block3-3): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=26, bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(208, 52, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(52, 208, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block3-4): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=26, bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(208, 52, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(52, 208, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block3-5): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=26, bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(208, 52, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(52, 208, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 208, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(208, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "    (block4): AnyStage(\n",
      "      (block4-0): ResBottleneckBlock(\n",
      "        (proj): Conv2dNormActivation(\n",
      "          (0): Conv2d(208, 440, kernel_size=(1, 1), stride=(2, 2), bias=False)\n",
      "          (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "        )\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(208, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), groups=55, bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(440, 52, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(52, 440, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block4-1): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=55, bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(440, 110, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(110, 440, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block4-2): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=55, bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(440, 110, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(110, 440, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block4-3): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=55, bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(440, 110, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(110, 440, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block4-4): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=55, bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(440, 110, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(110, 440, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "      (block4-5): ResBottleneckBlock(\n",
      "        (f): BottleneckTransform(\n",
      "          (a): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (b): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), groups=55, bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "            (2): ReLU(inplace=True)\n",
      "          )\n",
      "          (se): SqueezeExcitation(\n",
      "            (avgpool): AdaptiveAvgPool2d(output_size=1)\n",
      "            (fc1): Conv2d(440, 110, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (fc2): Conv2d(110, 440, kernel_size=(1, 1), stride=(1, 1))\n",
      "            (activation): ReLU()\n",
      "            (scale_activation): Sigmoid()\n",
      "          )\n",
      "          (c): Conv2dNormActivation(\n",
      "            (0): Conv2d(440, 440, kernel_size=(1, 1), stride=(1, 1), bias=False)\n",
      "            (1): BatchNorm2d(440, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n",
      "          )\n",
      "        )\n",
      "        (activation): ReLU(inplace=True)\n",
      "      )\n",
      "    )\n",
      "  )\n",
      "  (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))\n",
      "  (fc): Linear(in_features=440, out_features=10, bias=True)\n",
      ")\n",
      "[1,   100] loss: 0.609\n",
      "[1,   200] loss: 0.335\n",
      "[1,   300] loss: 0.298\n",
      "Epoch 1 took 181.79 seconds\n",
      "[2,   100] loss: 0.185\n",
      "[2,   200] loss: 0.200\n",
      "[2,   300] loss: 0.186\n",
      "Epoch 2 took 181.45 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 92.25 %\n"
     ]
    }
   ],
   "source": [
    "# regnet_y_400mf unfreezing parameters\n",
    "weights = torchvision.models.RegNet_Y_400MF_Weights.DEFAULT\n",
    "model = torchvision.models.regnet_y_400mf(weights)\n",
    "transforms = weights.transforms()\n",
    "trainloader, testloader = load_data(transforms)\n",
    "layers = nn.Linear(model.fc.in_features, len(classes))\n",
    "\n",
    "updated_model, optimizer = change_last_layer_unfreezing_parameters(model, layers)\n",
    "print(updated_model)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1,   100] loss: 1.235\n",
      "[1,   200] loss: 0.933\n",
      "[1,   300] loss: 0.843\n",
      "Epoch 1 took 123.72 seconds\n",
      "[2,   100] loss: 0.772\n",
      "[2,   200] loss: 0.761\n",
      "[2,   300] loss: 0.741\n",
      "Epoch 2 took 122.00 seconds\n",
      "Finished training\n",
      "Accuracy of the network on the 10000 test images: 74.79 %\n"
     ]
    }
   ],
   "source": [
    "# regnet_y_400mf freezing parameters\n",
    "model = torchvision.models.regnet_y_400mf(weights)\n",
    "updated_model, optimizer = change_last_layer_freezing_parameters(model, layers)\n",
    "updated_model.to(device)\n",
    "train_network(updated_model, trainloader, optimizer)\n",
    "percentage_accuracy.append(test_network(testloader, updated_model))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Гистрограмма точности моделей"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAABkAAAAGwCAYAAADxOakwAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMywgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/H5lhTAAAACXBIWXMAAA9hAAAPYQGoP6dpAABlBElEQVR4nO3dd3gU1f/28TsJPfTepGpCDQlCBOlVunRFioDSmyAlCEpXkN57b1KlfEVREGnSQQRDkQ4JIbQktEDKPH/wYx/WJLAJCZsd3q/r4rrImZlzzux+mAx778w4GYZhCAAAAAAAAAAAwESc7T0BAAAAAAAAAACA+EYAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKaTxN4TeBnDMBQZadh7GgAAAAAAAAAAwM6cnZ3k5ORk07qJPgCJjDR0584De08DAAAAAAAAAADYWcaMrnJxsS0A4RZYAAAAAAAAAADAdBL9FSAAAAAAAACIKjIyUj/8sFwbN67TzZuBypEjpxo3bqYmTT6yrHPmzGnNnTtDp0/7KjLSkLt7IXXu3EPu7oVe2PeRI4e0cOFcnTv3r5IlS6bixT3UtWsv5cqV27LOnDkztGTJgijbdu3aS5980jr+dhQAgDhyMgwjUT9gIyIikltgAQAAAAAA/MeUKeO1evVKNWzYRBUrVpGf3zXNmzdTtWrVU48evXXt2lW1a9dS7u6F9PHHLSU56YcflunUqX+0cOFy5cmTL9p+//77L/Xo0Unly1dUvXof6tGjUC1ePE93797VkiWrlD59eklS//5f6NGjR+rUqbvV9tmz51DmzJkTducBAG+sp7fAsu3mVlwBAgAAAAAA4GCCgoK0bt1q1a/fUH37DrS0Z82aTQMHfqkGDRrpxx/XKEWKFBo7drJSpkwpSXr33dJq1qy+1q5dpT59BkTb9/Lli5UvX36NGDFGzs5PP2Dy8Cihxo3rasuWzZarO/7996zq1KmvYsWKJ/DeAgAQNwQgAAAAAAAADubq1cuKiIhQuXIVrNpLliylyMhIHTjwp/Lmza8WLVpZwg9JSpkypbJkySo/P78Y+y5SpJgqVKhsCT8kKXPmLHJ1TS1//2uSngYwN28G6p133OJ5zwAAiD8EIAAAAAAAAA4mXbr0kqSAgOtW7X5+TwMKf38/ffFFvyjbXbt2VRcunNe773rH2Penn34Wpe3YsSO6dy9E+fMXkCT9++8ZSdKff+7R1KkTdevWTRUoUFAdO3ZT2bLl4rRPAADEN9tulAUAAAAAAIBEI0+evPLw8NT8+XO0c+cO3b9/X2fPntbo0SOULFkyPXr0KMo2jx+HatSoIUqWLLmaNv0oml6jFxQUpDFjRilz5iyqXbuepKe3v5Kk27dvy8dnsL79dpwyZMioAQN668CBffGzkwAAvCIegg4AAAAAAOCA7ty5rbFjv9Xu3TslSalTp1HXrj21YMEcVapURb1797es+/DhAw0c2Fd//XVUI0eOUYUKlW0a49atW/ryy+7y9/fXpEkzVLRoMUlSQECAzp//V2XKvC8XFxdJUnh4uNq2baGUKVNp7tzF8buzAAD8Hx6CDgAAAAAAYHIZM2bSd9+N171793Tr1k3lypVbzs7OGjfuO6VNm86y3o0bAerfv7euXr2s4cO/szn8OH/+nPr3/0IPHz7U+PFTLOGHJGXPnl3Zs2e3Wj9JkiQqXbqMNm5cFy/7BwDAqyIAAQAAAAAAcEDbtm1VvnwF9Pbb7yhNmjSSpNOnfRUZGSk3N3dJT0OMPn266/Hjx5owYZo8PUva1PfRo4c1cOCXcnVNrenT56pAgYJWy/ft26PHjx+rcuVqVu2PH4cqffoM8bB3AAC8Op4BAgAAAAAA4IAWL56vpUsXWrWtWrVCqVOnlpdXKd24EaAvvugqJycnzZw53+bw4+zZ0+rf/wtlzZpNc+YsihJ+SNKOHdv17bfDFRISbGl79OiR9u3bKy+vd19txwAAiCdcAQIAAAAAAOCAmjb9WOPGfacCBQqqePES2rZtq3777Rf17euj1KlTa9Soobp794769h2oBw8e6OTJE5ZtXV1dlT9/AUlPA4+kSZNZfh49eoTCw8P12WedFBAQoICAAMt2GTJkUK5cufXJJ220Y8c2ffllT7Vp006RkZFatmyxHj16pM8+6/R6XwgAAGLAQ9ABAAAAAAAc1OrVK7Vu3Srdvn1LefLkVYsWrVWjRi2FhYWpevXyioiIiHY7T8+SmjZtjiSpadP6yp49h6ZNmyM/v2v66KOGMY5Xu3Y9DRo0VJJ05sxpzZ49XadP+yosLEyenl7q0qWHChR4O753EwAAi9g8BJ0ABAAAAAAAAAAAOITYBCDcAsvBbNr0o1avXqmAAH9ly5ZdjRs3V+PGzeTk5CRJ2rt3txYtmqvz588pXbr0qlKlmj7/vItSpUr1wn6vXbuqKVMm6O+/j8nFxUVVqlRXly495OqaOtr1T58+pU6d2mrAgMGqU6d+vO8nANiDPY+xT5480cKFc7V16xYFBQXprbfyqE2b9qpWrUaC7jMAAAAAAIBZEYA4kM2bN+j770epadOPVL58JR0/fkyTJo3VkydP1KJFK+3cuUODB/eXl9e7Gj78O4WFhWnRovk6caKLZs6cryRJon+77927p549OytTpkwaNGio7t69qxkzpsjf318TJkyNsv6TJ080atSQGC+jBQBHZO9j7PDhX+vQof3q3LmHcud+S1u3btHQoV/J1dVVZcq8/7peBgAAgDeCs7OTnJ2d7D0NJHKRkYYiIxP1jVMAAC9BAOJAfvppkzw8PPXFF/0kSaVKeevKlctav361WrRopQUL5ihv3vwaP36qkiZNKkkqUcJLH33UUFu2bFaDBo2i7XfDhrUKCQnWggXLlT59eklSlixZ1a9fL/3991/y8PC0Wn/evJl68IDbkgEwF3seY48fP6Y//tiusWMnq2zZcpbx/fyuav/+PwlAAAAA4pGzs5PSp09l860z8OaKiIhUUNBDQhAAcGAEIA7kyZPHypQps1VbunTpFBwcLEm6fPmimjRpbvlgTpIyZsykvHnza9++PTF+OHfgwD55eHhZPpiTJG/vMkqVylX79u21CkBOnDiutWtXa/jwb+Xj82X87RwA2Jk9j7E7dmxXrly5LeGHJDk5OWnmzAXxuIcAAACQngYgLi7Omr5yr/wCg+09HSRSubKmU7cW5eTs7EQAAgAOjADEgTRr1kKjR4/Q1q1bVK5cRf3zzwn9/PNPqlWrriQpXbr0Cgi4brVNeHi4btwIUFjYkxj7vXz5UpR7zLu4uChHjpy6evWypS00NFSjRg1TmzbtVLDgO/G4ZwBgf/Y8xp47d1YFChTUr7/+osWL5+natavKnfstderUXRUrVo7fHQUAAIAkyS8wWJf87tp7GgAAIAERgDiQ6tU/0LFjRzRixDeWNm/vsurV6+mVGHXrNtCSJQu0bNki1a37oR4/fqy5c2fowYP7SpkyZYz9PnhwX6lSuUZpT5UqldWtrmbNmqpUqVKqVau2unkzMB73DADsz57H2KCgu7p69YrOnDmtDh26KHPmzFq/fq0GDeqnsWMncwssAAAAAACAOCAAcSA+Pl/q77//UteuPVW4cFFduHBOCxbM0ddfD9C3345T+/YdFRERoXnzZmnWrGlKkiSJ6tdvpPLlK+nSpQsx9hsZGRnjMienp/dEPXr0sDZt+lFz5iyO8UG/AODI7HmMDQsL0+3btzR//jK5uxeSJJUsWVpt27bQokXzCEAAAAAAAADigE+yHcSJE8d14MCfGjBgsOrXbyhJ8vJ6Vzlz5lK/fl/ozz/3qFy5CurSpYfat+8of38/Zc6cRWnSpFG3bh2UNm26GPtOnTq1Hj58GKX94cMHypIlqx4+fKjvvhuuli0/Vb58+RUeHm75QC8yMlLh4eGEIgAcmj2PsdLTq0EyZcpsCT+kp7fJKlXqPW3cuD5+dxYAAAAAAOAN4WzvCcA2z+47X7x4Cav2EiVKSpIuXjyvo0cP68CBfUqePLny5y+gNGnSKDw8XOfPn5Obm3uMfb/1Vl75+V21aouIiJC/v7/y5s2n06d9df26vxYunKvKlcuocuUy+uijhpKk0aNHqHLlMvG4pwDw+tnzGCtJuXPnUXh4mAzD+uGK4eHhSp48+avuHgAAAAAAwBuJr+07iGcfkh0/fkz58uW3tJ84cVySlDNnbv3xx3bt2bNLq1dvtFyR8dNPm3T//j1VqFA5xr69vctoxYolunv3rjJkyCBJOnhwvx49eihv7zIqWPBtzZu3xGqbW7duycenj9q166By5SrE454CwOtnz2OsJJUtW047dmzToUMHLG1hYWE6cOBPlSjhGc97CwCv36ZNP2r16pUKCPBXtmzZ1bhxczVu3ExOTk6SpJs3AzVjxhQdOLBP4eHhKly4qLp16yk3t0Iv7HfLls1auXKp/PyuKVOmLKpTp55at25ndXXytWtXNXv2dP39918KDX2kAgXe1mefdVKpUt4Jus8AAAAA7I8AxEG4uRVS5cpVNW3aRN27F6IiRYrp4sULWrhwjtzdC6tixcrKly+fNm/eoFGjhqpu3QY6d+6sZs2apmrVasjL611LX2fPnlbSpMmUP38BSVLDhk21bt0q9e7dTe3adVBISLBmzJiiMmXet3wbulChIlbzuX7dX5KUI0fOKMsAwNHY+xhbs2ZtrV27SsOHD1anTt2VJUtWrVnzg27eDNSIEWPs8poAQHzZvHmDvv9+lJo2/Ujly1fS8ePHNGnSWD158kQtWrTSw4cP1K1bByVLlkz9+g1UsmTJtWjRPPXu3U2LF69S5syZo+139eqVmjJlvCpXrqauXXspKOiu5s+frXPnzmrUqLGSpODgIHXv3lHp0qVTz55fytXVVZs3/6g+fbpr8uSZVsdvAAAAAObjZPz3fhuJTEREpO7ceWDvaSQKYWFhWrx4vrZu3aJbt24qW7bsqlixstq27aBUqVJJkg4d2q9Zs6br0qULypgxs2rXrqs2bdpbfQuuadP6yp49h6ZNm2Npu3DhnCZPnqCTJ48rVSpXVahQSd27f6FUqVyjncv16/5q1qyBvvpqiOrUqZ+wOw4Ar4G9j7EhISGaM2e6du7coYcPH8jNrZA6d+6uEiW8Xt+LAAAJoHPn9nJ2dtaMGfMsbUOGfCVf35Nas2aTFi2apx9+WKZly9Zawo7bt2/ps89aq1u3XqpRo1aUPiMiIlS/fk25uxfSxInTLe0XLpxTmzYfa+LEaSpduox++GGZZs2apjVrNlmeuxQREaG2bVsoR46c+v77SQm78wASpSRJnJUhg6u+mrxFl/zu2ns6SKTy5cqgb3vV0d27DxQeHmnv6QAAnpMxo6tcXGx7ugcBCAAAAIAE0759S2XKlFljx062tE2YMEa//LJFv/66U59+2kKFCxeRj8/XNvd569ZNNWxYW7169VWzZh9bLatXr7pq1KitXr2+1Pbtv+ns2dPq0qWH1ToDB/bVlSuXtHz52lfbOQAOiQAEtiAAAYDEKzYBCA9BBwAAAJBgmjVroYMH92vr1i26f/++DhzYp59//kkffFBH4eHhunTpgvLkyau5c2fqww8/UKVK76lHj066cOF8jH2mTp1GLi4uCgi4btUeEhKie/fuyd//miSpWrUaUcKPkJAQ/fXXUcutCgEAAACY1xvzDBBnZyc5OzvZexpIxCIjDUVGJuoLooBEieMrbMExFnhzVa/+gY4dO6IRI76xtHl7l1WvXl/q3r0QRUREaNWqFcqZM5cGDPhaYWFPNG/eLPXo0VGLF/+gzJmzROkzRYoUqlatptavX638+QuoYsUqCgq6o0mTxsvFxUWhoaHRziUyMlLffz9SDx8+0CeftEmwfQYAAACQOLwRAYizs5PSp09l82UxeDNFREQqKOghH9ABscDxFbbiGAu8uXx8vtTff/+lrl17qnDhorpw4ZwWLJijr78eoC++6GdZb/z4qZZnLrm7F1GLFo20bt1qderULdp++/YdqKRJk2rMmJEaPXqEkidPrlat2urRowdKnjxFlPXDw8M1atRQ/fHH7+rdu7+KFCmWMDsMAAAAINF4YwIQFxdnTV+5V36BwfaeDhKhXFnTqVuLcnJ2duLDOSAWOL7CFhxjgTfXiRPHdeDAnxowYLDq128oSfLyelc5c+ZSv35fqE6d+pa2Z+GHJGXPnl158+bX2bNnYuw7VapUGjjwG/Xq1VcBAdeVPXsOpUqVSps3b1CuXG9ZrXvv3j0NGtRPf/11VL1791OTJs3jf2cBAAAAJDpvRADyjF9gMA84A4AEwPEVABCdZ8/oKF68hFV7iRIlJUmXL19S+vQZFBb2JMq24eHhSp48eYx97927W2nSpJGHh6cKFCgoSbp7945u3gyUm1shy3qBgTfUu3c3Xb/ur6FDv1XVqtVfeb8AAAAAOAbuWQIAAAAgQeTNm0+SdPz4Mav2EyeOS5Jy5sytsmXL6fDhgwoKCrIsv3Llkq5evawSJTxj7HvjxnWaPn2yVdvq1Svl7OyscuUqSJIePLivXr266Natm5o4cTrhBwAAAPCGeaOuAAEAAADw+ri5FVLlylU1bdpE3bsXoiJFiunixQtauHCO3N0Lq2LFynJ3L6Tdu/9Qnz7d1LZtB4WFhWnu3BnKmjWb5bZZknTy5AllyJBBuXLlliQ1bfqx+vTprilTxqt8+Uo6fPigli5dqJYtP7WsM3/+bF29ekXt23eUi0sSnTx5wtJfsmRJra4UAQAAAGA+BCAAAAAAEsyQIaO0ePF8bdy4XvPnz1a2bNlVp059tW3bQUmSJFGuXLk1c+YCzZw5VSNGfCMXF2eVKvWeevbso1SpXC39dO7cTrVr19OgQUMlSd7eZTRkyEgtXrxAGzeuV/bsOfTFF33VtOnHlm3++ON3SdKCBXO0YMEcq3llz55Da9duTvgXAAAAAIDdEIAAAAAASDBJkybV55931uefd45xnfz5C+j77ye+sJ89ew5HaatRo5Zq1KgV4zbr1/9k+0QBAAAAmA4BCAAAAJAIOTs7ydnZyd7TQCIXGWkoMtKw9zQAAACARIkABAAAAEhknJ2dlD59Krm4ONt7KkjkIiIiFRT0kBAEAAAAiAYBCAAAAJDIODs7ycXFWdNX7pVfYLC9p4NEKlfWdOrWopycnZ0IQAAAAIBoEIAAAAAAiZRfYLAu+d219zQAAAAAwCFxTT0AAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDpJ7D0BAAAA2O7o0cPq2bNzjMvbt++oBQvmxLjcy+tdTZ06O8blW7Zs1sqVS+Xnd02ZMmVRnTr11Lp1OyVJEv1p49SpE3XmzClNmxbzmAAAAAAA2AMBCAAAgANxdy+kWbMWRmmfO3emTp/+R9WrfyBv77JRlu/a9btWrFiqhg2bxNj36tUrNWXKeFWuXE1du/ZSUNBdzZ8/W+fOndWoUWOjrL9y5TKtWrVcnp4lX22nAAAAAABIALEOQMLDwzV9+nRt2LBBQUFBKlKkiPr16ydPT09J0qlTpzRq1CidPHlSGTNmVNu2bdWmTZv4njcAAMAbydU1tYoVK27VtmfPTh05clAjRoxWnjx5o2xz40aANm3aoMaNm6latZrR9hsREaFFi+apdOn3NHLkGEu7u3shtWnzsQ4d2q/SpctIkvz9/TRt2iTt3btLqVOnjse9AwAAAAAg/sT6GSAzZ87UmjVrNGLECG3YsEH58+fX559/rsDAQN29e1ft2rVTnjx5tG7dOnXr1k3jxo3TunXrEmLuAAAAb7zHj0M1ceJYvf9+eVWpUj3adaZNm6TkyZOrU6duMfZz9+4dhYQE6/33K1i1FyjwttKnT68//9xraZs6dYKuXbuiyZNn6u233eJnRwAAAAAAiGexvgJk27ZtqlevnsqXLy9J8vHx0Zo1a/TXX3/p4sWLSpo0qYYPH64kSZKoYMGCunz5subMmaMmTWK+3QIAAADiZvXqH3Tr1k1Nnjwz2uUnT57Qjh3b9NVXQ+TqGvPVGqlTp5GLi4sCAq5btYeEhOjevXvy979maevQoYvy5y8oJyen+NkJAAAAAAASQKwDkEyZMmnHjh1q1aqVcuTIoVWrVilZsmQqVKiQ1qxZI29vb6uHZJYpU0azZ8/WrVu3lDlz5nidPADHYctDe9u376ibNwM1Y8YUHTiwT+Hh4SpcuKi6despN7dC0W53/bq/mjVrEGO/derU11dfDXnl+QNAYhQWFqa1a1eqWrWayp37rWjXWbFiiXLkyKmaNWu/sK8UKVKoWrWaWr9+tfLnL6CKFasoKOiOJk0aLxcXF4WGhlrWLVDg7XjdDwAAAAAAEkKsA5BBgwapV69eqlatmlxcXOTs7KypU6cqT548CggIkJub9W0QsmbNKkm6fv16nAOQJElifacuKy4ur7Y93hzUSsIpWrSI5s1bFKV91qwZOnXKV7Vq1dbjx4/UvXtHJU2aVD4+g5QsWTItWDBPvXt31/Llq5Q5c5Yo22fLljXafteuXa1t235VgwYNX/kYgpjxbwaxQb3Ev+3bf9ft27fVuvWn0R7rAgNvaM+enerVq49SpEj20v58fAYpefJkGjNmpEaPHqHkyVOoTZu2evTooVKkSBHtGM+uAuFYG7/494LYoF6A2OHfDGKDegEAxxbrAOTcuXNKkyaNpk+frmzZsmnNmjXq27evli1bptDQUCVLZv2f6+TJk0uSHj9+HKcJOjs7KUMG1zhtC8RW2rQp7T0F08qQwVW5c2ezatu+fbsOHz6oyZMnq0SJIpo+fbpCQoK1ZcsWS3hapkwpNW7cWGfOnNQ779SLpmdXZctW1qrl5MmT2r79N/Xp00dVqpRPqF0CEEscY+Pfnj1/6J133pG3t1e0yzdv3iMnJyc1bdrIpvOpDBlcNW7c9xo2bIj8/f2VM2dOubq6qnLljSpYMH+0fSRN6mLZFoB9cHwFgITDMRYAHFusApDr16/ryy+/1KJFi1SqVClJUvHixXXu3DlNnTpVKVKk0JMnT6y2eRZ8pEqVKk4TjIw0FBLyME7bPuPi4swvLNgkJOSRIiIi7T2NN0JoaKiGDx+ucuXK6733Kuju3QfasuVnVa5cTUmTuuru3QeSpCRJUmnTpl8kydL2IoZh6Jtvhihfvvz68MNmNm2DuOP4itjgGBu/wsPDtHv3brVu3TbGY91vv22Xp6eXXFxS2nQ83LNnl9KkSasSJTyVOXNOPXkiBQRcVUBAgPLnfzvaPsLCIiTZdoyG7Ti+IjY4vgKxwzEWscExFgASn7RpU9p8hV6sApDjx48rLCxMxYsXt2ovUaKEdu3apZw5cyowMNBq2bOfs2Wz/uZ3bISH84sGr0dERCT19pqsXLlCN2/e1KRJMxUeHqnw8HBdvHhBNWvW1syZ0/W//21QUFCQPDw81bt3fxUoUNCmfrdt26p//jmpKVNmyTCceD+BRIRjbPw6c+ZfhYaGqmhRj2hfV8Mw5Ot7Uk2afGTz675+/VoFBwdr9uyFlraVK5fL2dlZZcqUj3EcifM1wJ44vgJAwuEYCwCOLVY3MsyePbsk6cyZM1btZ8+eVb58+VS6dGkdOXJEERERlmX79+9X/vz5lSlTpniYLgAziO6hvffuhSgiIkKrVq3Q0aOHNWDA1xo+/DsFBd1Vjx4ddevWTZv6XrFiqYoXL6GSJUsl5C4AgN1duHBOkpQvX4Fol9+4EaD79+8rX778MfZx8uQJ+flds/zctOnH+uefE5oyZbyOHj2sOXNmaOnShfr441bKlSt3/O4AAAAAAAAJLFYBiIeHh959910NGDBA+/fv16VLlzRp0iTt27dPHTt2VJMmTXT//n0NGjRI586d0/r167Vo0SJ16tQpoeYPwAHt2LFdt2/fVosWrS1tYWFhlr+PHz9V779fXpUqVdXYsVP08OFDrVu3+qX9njhxXGfPntYnn7R+6boA4Oju3LktSUqTJs1LlqeNsY/Ondtp0aJ5lp+9vctoyJCROnjwgPr166WdO3/XF1/0VZcuPeJx5gAAAAAAvB6xugWWs7OzZs6cqUmTJmngwIEKDg6Wm5ubFi1apBIlSkiS5s2bp1GjRqlRo0bKkiWL+vfvr0aNGiXI5AE4pj/+2K78+QvonXfcLG2pUj19eK6X17tWzwzKnj278ubNr7Nnz0TpJ7p+06RJq7JlefA5APNr2fJTtWz5aYzLixQppj17Dr+wj+iW16hRSzVq1LJ5HtOmzbF5XQAAAAAAXqdYBSCSlC5dOg0ZMkRDhgyJdrmHh4dWrVr1yhMDYE7h4eE6eHBflA/tUqdOrfTpMygs7Em02yRPnvylfe/du0cVKlRSkiSxPrQBAAAAAIAEcvToYfXs2TnG5e3bd1T79h2t2lavXqkpU8ZrzZpNypEjZ7TbXb/ur2bNGsTYb5069fXVV08/wzx58m/Nnj1dvr4nlTJlKr3/fnl17txdGTNy237AzPiUEMBrdf78OYWGhqp48RJRlpUtW067du1QUFCQ0qdPL0m6cuWSrl69rPr1P3xhvyEhwbp27YpatWqTENMGYBLOzk5ydnay9zSQyEVGGoqMNOw9DQAAANNwdy+kWbMWRmmfO3emTp/+R9Wrf2DVfuXKZc2ePe2l/WbKlDnafn/8cbW2b/9Ndes+/SzB1/ekevTopLx582vQoGFKnjy5Vq5cqk6d2mvhwuVKnTp1HPcMQGJHAALgtXrRQ3vbtv1cu3f/oT59uqlt2w4KCwvT3LkzlDVrNtWv39Cy3smTJ5QhQwarB/KeP//ihwEDgLOzk9KnTyUXl1g9Ag1voIiISAUFPSQEAQAAiCeurqlVrFhxq7Y9e3bqyJGDGjFitPLkyWtpj4iI0LffDlO6dOkVGHjjhf0mS5YsSr+nT5/S9u2/qWPHbipRwlOStGTJArm6ptaUKbOUNu3TZ+S9+25pffJJEy1fvlidOnWLh72EWSTUFUvPbNmyWStXLpWfn5+yZcumxo2bq2nTj+Tk9P+/rPfnn3u0YMEcXbp0QenSpVedOvXVpk17JU2a9NV27g1EAALgtXrRQ3tz5cqtmTMXaObMqRox4hu5uDirVKn31LNnH8szQqSnD+2tXbueBg0a+ly/d/6v35gf9gvgzebs7CQXF2dNX7lXfoHB9p4OEqlcWdOpW4tycnZ2IgABAABIII8fh2rixLF6//3yqlKlutWylSuX6s6d22rVqq0mTBgTq34Nw9CECWOUL18BffTRJ5b2S5cuycPD0xJ+SFKKFClUpEgx7du3lwAEVhLqiiVJ2rx5g8aMGalPPmkjb+8y8vU9qWnTJurRo4dq06a9JOngwf3y8emjWrXqqlOnbrpy5ZJmzZquW7duacCAQa++g28YAhAAr9XLHtqbP38Bff/9xBf2Ed1De6tVq6Fq1Wq88vwAmJ9fYLAu+d219zQAAACAN9bq1T/o1q2bmjx5plX7hQvntWDBXI0fP0XXr/vHut/t23+Vr+9JTZkySy4uLpb29OnTKyDgepT1/f2vyd/fL/Y7AFNLqCuWJGnJkoWqXLmaunbtKUkqVcpbV69e0bp1qywByNKlC+XuXsjy/JrSpd9TUFCQlixZoJ49+yhlypTxtatvBO4BAQAAAAAAAOC1CAsL09q1K1WtWk3lzv2WpT08PFwjRw5R/fofysvr3Tj1vWLFUhUvXkIlS5ayaq9bt4HOnj2tyZPH69atm7p9+5ZmzJiiS5cuKjT00SvtD8zP1iuWbDF27CR169bLqi1JkqR6/PiJ5Wcfn6/19dfDrdZJmjSpIiMjFR4eHredeINxBQiQCPGQXtiCh/QCAAAAABzNjh3bdfv2bbVo0dqqfcmSBbp//546d+4Rp35PnDius2dP67vvxkVZVr9+Qz14cF/z58/WmjUr5eTkpMqVq6lBg0b66afNcRoPb474vGIpX778kp7eru3evRDt3LlDW7f+pI8+amlZ5/ln3j54cF+HDx/UypXLVL36B9HeUh4vRgACJDI8pBe24iG9AAAAAABH88cf25U/fwG9846bpe3s2dNaunShxo6drKRJkyo8PFyRkZGSpMjISEVERFjd0iqmftOkSauyZctHu/zjj1upadOP5ed3TWnTplOGDBk0YsQ3Vs8FAf7L1iuWYnvLtn/+OaHOnZ/e8qpQoSJq0aJVlHVu3bqlhg1rSZJy5syljh27vsKevLkIQIBEhof0whY8pBcAAAAA4GjCw8N18OC+KM8G3b17p8LCwvTFF1E/4P3oo4by9CypadPmvLDvvXv3qEKFSkqSJOrHnadP++rGjQBVqlRVefPms7SfPXtabm6F4rYzeCMk1BVL2bPn0NSps3X9ur/mzp2pzp3ba8GC5UqRIoVlneTJk2vy5JkKDg7WggWz1alTO82fv1RZsmR9pX160xCAAIkUD+kFAAAAAABmcv78OYWGhqp48RJW7R9+2FjlylWwatu7d7cWLpyr0aMnKE+ePC/sNyQkWNeuXVGrVm2iXX706BHNmzdLGzeWttxC6NCh/bp48YI++ST6bQAp4a5Yypw5izJnziIvr3eVM2cude/eUTt2bFPt2vUs66RJk0bvvltaklS4cBE1b/6h/ve/jWrXrkMC7Kl5EYAAAAAAAAAASHAXLpyTJOXLV8Cq/dmHwdbrnpckFSz4tnLkyGlpP3nyhDJkyGD1nITz56Pv95kPPqitZcsW6ZtvfPTJJ61140aApk6dqOLFS6hmzdqvvmMwpfi+Yunhw4fas2eXihQpanU7rWdXId26dUsRERH644/f9dZbb1ldnZQjR06lTZtWt27djK/de2MQgAAAAAAAAABIcHfu3JakV3qQc+fO7VS7dj0NGjT0uX7v/F+/0T/PI1OmzJowYZqmTZuor77qrzRp0qhOnQbq0KHzS7+pjzdXfF+x5OLiojFjRuiDD+qof/9BlvZDh/ZLkt5++225uLho1qxpeuuttzRhwjTLOmfOnFZwcLAKFnwnvnbvjUEAAgAAAAAAACDBtWz5aZRv08ekTp36qlOnfpT2PXsOR2mrVq2GqlWr8cL+ChUq/NLniADPi+8rlpInT67Wrdtp/vzZypAho0qWLKVz585q4cK5KlXKW2XKlJMktW/fQaNGDdW4cd+pcuVq8vf30/z5s1WgQEHVrRv13wRejAAEAAAAAAAASKScnZ3k7Oxk72kgkYuMNBQZadh7GqaSEFcsffrpZ0qfPr3WrVutlSuXKX369PrwwyZq376jnJye/juvXbueUqRIoWXLFuuXX35SypSpVLFiZXXq1F3Jk6d4wWiIDgEIAAAAAAAAkAg5OzspffpUcnFxtvdUkMhFREQqKOghIUg8SogrlpycnNSwYVM1bNj0hf1VqVJdVapUt32yiBEBCAAAAAAAAJAIOTs7ycXFWdNX7pVfYLC9p4NEKlfWdOrWopycnZ3sHoBwxRJs8TqvWCIAAQAAAAAAABIxv8BgXfK7a+9pAC/EFUuw1eu8YokABAAAAAAAAADwSrhiCbZ43VcsEYAAAAAAABCNo0cPq2fPzjEub9++o9q376hr165qypQJ+vvvY3JxcVGVKtXVpUsPubqmtmmchw8f6NNPW6hduw7R3j8cAABHwhVLSEwIQAAAAAAAiIa7eyHNmrUwSvvcuTN1+vQ/ql79A927d089e3ZWpkyZNGjQUN29e1czZkyRv7+/JkyY+tIxQkJCNHDgl7p+3T8hdgEAAOCNRgACAAAAAEA0XF1Tq1ix4lZte/bs1JEjBzVixGjlyZNXS5cuVEhIsBYsWK706dNLkrJkyap+/Xrp77//koeHZ4z979mzU5MmjdPDhw8TcC8AAADeXDyRBgAAAAAAGzx+HKqJE8fq/ffLq0qV6pKkAwf2ycPDyxJ+SJK3dxmlSuWqffv2xtjXvXv39NVX/eTpWdKmK0UAAAAQe1wBAgAAAACADVav/kG3bt3U5MkzLW2XL19StWo1rNZzcXFRjhw5dfXq5Rj7SpEihZYtW608efJx+ysAAIAEwhUgAAAAAAC8RFhYmNauXalq1Woqd+63LO0PHtxXqlSuUdZPlSqVHjx4EGN/SZMmVZ48+RJiqgAAAPg/BCAAAAAAALzEjh3bdfv2bbVo0dqqPTIyMsZtnJz4LzcAAIA9cTYGAAAAAMBL/PHHduXPX0DvvONm1Z46depoH2L+8OEDpU6d+nVNDwAAANEgAAEAAAAA4AXCw8N18OA+Va1aI8qyt97KKz+/q1ZtERER8vf3V968+V7TDAEAABAdAhAAAAAAAF7g/PlzCg0NVfHiJaIs8/Yuo7/+Oqq7d+9a2g4e3K9Hjx7K27vM65wmAAAA/oMABAAAAACAF7hw4ZwkKV++AlGWNWzYVMmTJ1fv3t20c+cObd68QcOHf60yZd63CkxOnjwhP79rr23OAAAAIAABAAAAAOCF7ty5LUlKkyZNlGUZMmTQlCmzlC5deg0fPlhz5sxQlSrVNHz4d1brde7cTosWzXst8wUAAMBTSew9AQAAAAAAErOWLT9Vy5afxri8QIG3NXnyjBf2sWfP4RiX5ciR84XLAQAAEDdcAQIAAAAAAAAAAEyHK0AAAAAAAK/M2dlJzs5O9p4GErHISEORkYa9pwEAAN4gBCAAAAAAgFfi7Oyk9OlTycWFmwwgZhERkQoKekgIAgAAXhsCEAAAAADAK3F2dpKLi7Omr9wrv8Bge08HiVCurOnUrUU5OTs7EYAAAIDXhgAEAAAAABAv/AKDdcnvrr2nAQAAAEjiIegAAAAAAAAAAMCECEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOnEKQDZs2KA6deqoePHiqlu3rn7++WfLsmvXrqlTp04qWbKkypcvr0mTJikiIiLeJgwAAAAAAAAAAPAysQ5ANm7cqEGDBqlly5b66aefVK9ePfXp00fHjh1TWFiYPvvsM0nSDz/8oKFDh2rlypWaPn16vE8cAAAAAAAAAAAgJklis7JhGJo8ebLatGmjli1bSpK6dOmiw4cP6+DBg/Lz85O/v79Wr16tdOnSyc3NTbdv39b333+vzp07K1myZAmyEwAAAAAAAAAAAM+L1RUgFy9elJ+fn+rXr2/VPn/+fHXq1EmHDx9W0aJFlS5dOsuyMmXK6P79+zp16lT8zBgAAAAAAAAAAOAlYnUFyMWLFyVJDx8+1GeffSZfX1/lzp1bXbp0UdWqVRUQEKDs2bNbbZM1a1ZJ0vXr11WiRIm4TTLJqz2r3cWFZ73DNomhVhLDHOA47F0v9h4fjsXe9WLv8eFY7F0v9h4fjiUx1EtimAMcQ2KolcQwBzgOe9eLvceHY7F3vdh7fDiW11UvsQpA7t+/L0kaMGCAunfvrr59+2rr1q3q2rWrFi5cqNDQUKVNm9Zqm+TJk0uSHj9+HKcJOjs7KUMG1zhtC8RW2rQp7T0FIFaoWTgS6hWOhHqFI6Fe4UioVzgaahaOhHqFI3ld9RqrACRp0qSSpM8++0yNGjWSJBUuXFi+vr5auHChUqRIoSdPnlht8yz4SJUqVZwmGBlpKCTkYZy2fcbFxZkDAGwSEvJIERGRdp0D9YrYsHfNUq+IDeoVjoR6hSOxd71K1CxsR73C0di7ZqlXxAb1CkfyKvWaNm1Km68giVUAki1bNkmSm5ubVfvbb7+tP/74Q97e3jp79qzVssDAQKtt4yI83L4nR3hzREREUm9wKNQsHAn1CkdCvcKRUK9wJNQrHA01C0dCvcKRvK56jdWNtooWLSpXV1cdP37cqv3s2bPKkyePSpcuLV9fX8utsiRp//79cnV1VaFCheJnxgAAAAAAAAAAAC8RqwAkRYoU+vzzzzV9+nT973//05UrVzRz5kzt3btX7dq1U/Xq1ZUlSxZ98cUXOn36tLZt26YJEyaoffv2SpYsWULtAwAAAAAAAAAAgJVY3QJLkrp27aqUKVNq4sSJunHjhgoWLKipU6fqvffekyTNmzdPw4YNU/PmzZUuXTp98skn6tq1a7xPHAAAAAAAAAAAICaxDkAkqV27dmrXrl20y/LmzasFCxa80qQAAAAAAAAAAABeRaxugQUAAAAAAAAAAOAICEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKYT5wDk4sWL8vLy0vr16y1tp06dUqtWreTp6amqVatqyZIl8TJJAAAAAAAAAACA2IhTABIWFqa+ffvq4cOHlra7d++qXbt2ypMnj9atW6du3bpp3LhxWrduXbxNFgAAAAAAAAAAwBZJ4rLR1KlTlTp1aqu21atXK2nSpBo+fLiSJEmiggUL6vLly5ozZ46aNGkSL5MFAAAAAAAAAACwRayvADl06JBWrVql0aNHW7UfPnxY3t7eSpLk/2cqZcqU0aVLl3Tr1q1XnykAAAAAAAAAAICNYnUFSEhIiPr376/BgwcrR44cVssCAgLk5uZm1ZY1a1ZJ0vXr15U5c+a4TzLJqz2r3cWFZ73DNomhVhLDHOA47F0v9h4fjsXe9WLv8eFY7F0v9h4fjiUx1EtimAMcQ2KolcQwBzgOe9eLvceHY7F3vdh7fDiW11UvsQpAhg4dKi8vL9WvXz/KstDQUCVLlsyqLXny5JKkx48fx3mCzs5OypDBNc7bA7GRNm1Ke08BiBVqFo6EeoUjoV7hSKhXOBLqFY6GmoUjoV7hSF5XvdocgGzYsEGHDx/W5s2bo12eIkUKPXnyxKrtWfCRKlWqOE8wMtJQSMjDl6/4Ai4uzhwAYJOQkEeKiIi06xyoV8SGvWuWekVsUK9wJNQrHIm961WiZmE76hWOxt41S70iNqhXOJJXqde0aVPafAWJzQHIunXrdPv2bVWuXNmqfciQIdqyZYuyZ8+uwMBAq2XPfs6WLZutw0QrPNy+J0d4c0RERFJvcCjULBwJ9QpHQr3CkVCvcCTUKxwNNQtHQr3CkbyuerU5ABk3bpxCQ0Ot2mrWrKmePXuqQYMG2rhxo3744QdFRETIxcVFkrR//37lz59fmTJlit9ZAwAAAAAAAAAAvIDNTxrJli2b8ubNa/VHkjJlyqRs2bKpSZMmun//vgYNGqRz585p/fr1WrRokTp16pRgkwcAAAAAAAAAAIhOvD1qPVOmTJo3b54uXryoRo0aadq0aerfv78aNWoUX0MAAAAAAAAAAADYxOZbYEXnzJkzVj97eHho1apVrzQhAAAAAAAAAACAVxVvV4AAAAAAAAAAAAAkFgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpxDoACQoK0jfffKOKFSuqZMmSatGihQ4fPmxZvm/fPjVu3FglSpRQrVq19NNPP8XrhAEAAAAAAAAAAF4m1gFInz59dOzYMU2YMEHr1q1T4cKF9dlnn+nChQs6f/68OnXqpAoVKmj9+vVq1qyZ+vfvr3379iXE3AEAAAAAAAAAAKKVJDYrX758WXv37tWKFSv07rvvSpK+/vpr7d69W5s3b9bt27fl7u6u3r17S5IKFiwoX19fzZs3T2XLlo3/2QMAAAAAAAAAAEQjVleAZMiQQXPmzFHx4sUtbU5OTnJyclJISIgOHz4cJegoU6aMjhw5IsMw4mfGAAAAAAAAAAAALxGrK0DSpk2rSpUqWbVt3bpVly9f1ldffaUff/xR2bNnt1qeNWtWPXr0SHfv3lXGjBnjNskkr/asdhcXnvUO2ySGWkkMc4DjsHe92Ht8OBZ714u9x4djsXe92Ht8OJbEUC+JYQ5wDImhVhLDHOA47F0v9h4fjsXe9WLv8eFYXle9xCoA+a+jR49q4MCBqlmzpipXrqzQ0FAlS5bMap1nPz958iROYzg7OylDBtdXmSZgs7RpU9p7CkCsULNwJNQrHAn1CkdCvcKRUK9wNNQsHAn1Ckfyuuo1zgHItm3b1LdvX5UsWVLjxo2TJCVPnjxK0PHs55Qp47ZDkZGGQkIexnWakp6mSRwAYIuQkEeKiIi06xyoV8SGvWuWekVsUK9wJNQrHIm961WiZmE76hWOxt41S70iNqhXOJJXqde0aVPafAVJnAKQZcuWadSoUapVq5bGjBljucojR44cCgwMtFo3MDBQqVKlUpo0aeIylCQpPNy+J0d4c0RERFJvcCjULBwJ9QpHQr3CkVCvcCTUKxwNNQtHQr3Ckbyueo31jbZWrFihESNGqGXLlpowYYLVLa9KlSqlgwcPWq2/f/9+lSxZUs7O3AMOAAAAAAAAAAC8HrG6AuTixYv69ttvVaNGDXXq1Em3bt2yLEuRIoVat26tRo0aady4cWrUqJF27typX375RfPmzYv3iQMAAAAAAAAAAMQkVgHI1q1bFRYWpt9++02//fab1bJGjRpp9OjRmjFjhsaOHavFixcrd+7cGjt2rMqWLRuvkwYAAAAAAAAAAHiRWAUgnTt3VufOnV+4TsWKFVWxYsVXmhQAAAAAAAAAAMCr4MEcAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTIQABAAAAAAAAAACmQwACAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApkMAAgAAAAAAAAAATIcABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMhAAEAAAAAAAAAAKZDAAIAAAAAAAAAAEyHAAQAAAAAAAAAAJgOAQgAAAAAAAAAADAdAhAAAAAAAAAAAGA6BCAAAAAAAAAAAMB0CEAAAAAAAAAAAIDpEIAAAAAAAAAAAADTifcAJDIyUlOmTFGFChXk6empDh066OrVq/E9DAAAAAAAAAAAQIziPQCZMWOGVqxYoREjRuiHH35QZGSkPv/8cz158iS+hwIAAAAAAAAAAIhWvAYgT5480YIFC9SzZ09VrlxZhQoV0sSJExUQEKBff/01PocCAAAAAAAAAACIUbwGIKdPn9aDBw9UtmxZS1vatGlVpEgRHTp0KD6HAgAAAAAAAAAAiFG8BiABAQGSpBw5cli1Z82a1bIMAAAAAAAAAAAgoTkZhmHEV2cbN25U//79derUKTk7//9spX///goMDNSiRYti3adhGIqMfLUpOjlJzs7OCr4fqoiIyFfqC+bk4uKsdKlTKDIyUvH3LyJuqFfYIrHULPUKW1CvcCTUKxxJYqlXiZrFy1GvcDSJpWapV9iCeoUjiY96dXZ2kpOTk03rJonbENFLkSKFpKfPAnn2d0l6/PixUqZMGac+nZyc5OJi2868TLrUKV6+Et5ozwd39ka9whaJpWapV9iCeoUjoV7hSBJLvUrULF6OeoWjSSw1S73CFtQrHMnrqtd4HeXZra8CAwOt2gMDA5UtW7b4HAoAAAAAAAAAACBG8RqAFCpUSKlTp9aBAwcsbSEhIfL19VXp0qXjcygAAAAAAAAAAIAYxestsJIlS6ZWrVpp3Lhxypgxo3LlyqWxY8cqe/bsqlmzZnwOBQAAAAAAAAAAEKN4DUAkqWfPngoPD9fgwYMVGhqq0qVLa/78+UqaNGl8DwUAAAAAAAAAABAtJ8OI67PWAQAAAAAAAAAAEqfX86h1AAAAAAAAAACA14gABAAAAAAAAAAAmA4BCAAAAAAAAAAAMB0CEAAAAAAAAAAAYDoEIAAAAAAAAAAAwHQIQAAAAAAAAAAAgOkQgAAAAAAAAAAAANMxZQDSunVrubu7W/0pVqyYKleurOHDh+vRo0fxNtbUqVPl7u6u33//PcqyAwcOyN3dXdeuXbO5v3///Vd//PFHtMtmz56t1q1bR2n/559/1Lp1a3l5ealy5coaN26cnjx5YvOY8WXYsGHy8vLSu+++q1u3br328aWn70fVqlXtMnZCoqZjX9PUY8IxUz3evn1b/fr1U5kyZeTl5aWOHTvq/PnzMW4/ePBgu72n1HTCoaZj/55Sj7bZtGmTmjdvLk9PT3l5ealJkyb64YcfrNapWrWqpk6d+krjXL16VU2aNFGxYsXUq1evKD/7+PhE+/s2Jq/zXCAuQkNDNX78eFWtWlVeXl5q3Lixtm/fHm/92+rEiROqXbu2ihUrpjFjxrz28Z9xd3fX+vXrE3wc6vmpxFjPb1otJpTXeT7wbLxSpUopICAgyrK4/I7bsWOHzp07F1/Ts0lQUJDatm2r4sWLq2nTpq917Oe1bt1aPj4+dhs/sXrTapp6xKuIiIjQihUr1LRpU3l5ealUqVL6+OOPtXbtWhmGEe/jXbt2Te7u7urRo0e0y2N7TvXw4UMtX748vqZnOqYMQCSpdu3a2rNnj+XPTz/9pA4dOmj16tUJclL4zTffKDg4+JX76dSpk06cOBGlffny5Zo0aVKU9rt376p9+/YqUKCANmzYoBEjRmj9+vXRrpuQTp8+rRUrVmjAgAHauHGjMmfO/FrHf6Z9+/Zau3atXcZOaNR01HVjQj0mPLPUY7du3XT58mXNmTNHa9euVYoUKdS2bdto/zOwbds2rVmz5pXnEBfUdMKjpm1HPdpm7dq1GjJkiJo3b64ff/xR69atU8OGDTVy5EhNmzYtXsdatmyZAgICtHHjRn3zzTdRfo6rhD4XiKuRI0dq8+bNGjJkiDZs2KDq1aure/fuOnDgQLyNYYvZs2cradKk2rJlizp27Phax37enj17VKdOnQQdg3r+/xJjPb9JtZjQXvf5wL179zR48OBX7sfPz0+dO3fW7du342FWttu0aZMOHz6s5cuXa/r06a917OdNnTpVgwYNstv4idmbVNPUI+IqLCxMXbp00ZQpU9SwYUP9+OOPWrVqlWrVqqXRo0erW7duioiISJCxf/31V/3000+v3M+CBQs0f/78eJiROZk2AEmRIoWyZMli+ZM3b161bNlS9evX15YtW+J1rHTp0unJkycaOXJkvPYrSTdu3FDnzp01btw45cuXL8ryI0eOKCgoSP369VPevHlVoUIF1a9fX7t37473ubxISEiIJKlcuXLKnTv3ax37ea6ursqYMaPdxk9I1LTtNU09Jjwz1GNwcLBy5cqlkSNHysPDQwULFlTXrl0VGBiof//912rdwMBAff311/L29o7XOdiKmk541LTtqEfbrFixQk2aNFHTpk2VP39+FShQQK1bt1bbtm21ZMmSeB0rJCRE+fPnV8GCBZUpU6YoP8dFQp4LvIpHjx5pw4YN6tOnjypVqqS8efOqa9eu8vb21rp1617rXIKDg1W4cGHlyZNHGTJkeK1jPy9LlixKkSJFgo5BPSeM+KrnN6kWE9rrPB+QpLfeeku7d+9+5S/ZJMS3k20REhKiLFmyyMPDQ9myZbPLHCQpffr0SpMmjd3GT8zepJqmHhFXs2fP1uHDh7VixQq1atVK+fLlU8GCBS3nObt27UqwcOGtt97S8OHDX/mqenv9HnAUpg1AYpI8eXIlSZLE8vOTJ080duxYVahQQV5eXmrevLn27NljWR4REaGxY8eqUqVKKlasmGrVqqWVK1da9Zk6dWp99dVX2rRp00svV163bp1q164tDw8P1a5dW4sXL1ZkZKSkp5c3+fn5adq0aZbLuv/55x8lTZpUmzZtUokSJaL09+w//itXrlRERISuXbumnTt3RrtuTKK7FPG/be7u7lq7dq3atm0rDw8PlS9f3vJtr/Xr11vmW716dfn4+OjAgQMqUqSI5syZo/fee0+NGzdWZGSkbty4od69e6tUqVJ677331LlzZ126dMnm18jHxyfKJZzu7u6WuT4/72eXk23dulXNmjVTsWLFVLVqVa1atcpqvEWLFqlq1ary8PBQu3btNG3atER/S43nUdPWqEf7cqR6TJcuncaPHy83NzdJ0p07d7Ro0SJlz55db7/9tqVPwzDk4+OjDz/8ME4fFnOMpabNVNPUo+2cnZ117NixKN8479ixY5R53bx5U927d5enp6fee+89fffdd5Zvma1fv17u7u5W6z/f1rp1a61fv16HDh2Su7t7lJ+j+xa5Le9NQp4LvMjVq1dVqFAh7dy506p94MCBatGihZycnDRr1ixVrFjRarmzs7MlnLNFdLfqeb5t6tSpatu2rebMmaOKFSuqePHiatWqleWWclWrVtXBgwe1YcMGyy2UWrdura+//lrNmjVTqVKltGnTppe+PtKL349ntR3dnx9//DHKvH18fOTj46MxY8aobNmyKlGihDp16qQbN25Yxrty5Yo6dOggLy8vVahQQQsXLlSNGjVeeOsi6jnx1vObVov2EtvzAenpFTGNGjVS8eLFVa9ePa1bty7KLddKlSqlJk2aaPTo0bp+/XqM479ovGvXrqlatWqSpDZt2th8y5TobtPzfNuz3+87d+5UvXr1LOc127Ztk/T0PZ46dar8/f0t7/3UqVPVqlUr9e7dWyVLltSIESMkSUePHlXLli3l4eGhypUra9iwYbp//77Nr2fVqlWjrb2BAwdGmff69estdVSjRg0VK1ZMjRs31pEjRyz9PXr0SEOGDNF7772nkiVLatCgQfryyy/fqNsWma2mqUfEVWRkpJYuXarGjRurQIECUZYXKVJEH374oZYuXarIyEjL78Pnz0n+2+bj46OePXuqffv2KlmypObOnRvj+H379pWLi4uGDh36wnmeP3/e8juzfPny+vLLL3Xz5k1JT89bp02bJj8/v1jf2vONYZhQq1atjAEDBli1hYWFGTt27DA8PT2N0aNHW9r79OljfPjhh8b+/fuNixcvGgsWLDCKFi1q7NixwzAMw1iyZIlRtWpV48iRI8a1a9eMpUuXGm5ubsahQ4cMwzCMKVOmGFWqVDEMwzA6d+5slCtXzrh7965hGIaxf/9+w83Nzbh69aphGIbxww8/GN7e3sb//vc/48qVK8Yvv/xilCtXzhgzZoxhGIZx+/Zto2LFisbo0aMtfTxvwIABRqtWraK0T5w40ShatKhRuHBhw83NzWjTpo3x+PFjm1+v5/chpjY3NzejVKlSxoYNG4wrV64YM2fONNzc3IyDBw8ajx49MrZu3Wq4ubkZx48fN0JCQiz7/sknnxgXL140fH19jQcPHhg1atQwvvjiC+PUqVPGmTNnDB8fH6N06dJGQECATa9RSEiIERgYaPnz888/G4ULFzbWr18fZd5Xr1413NzcjEqVKhnbtm0zrly5YgwbNswoVKiQceXKFcMwDGPZsmWGh4eHsWbNGuPChQvGjBkzjEKFCkV5PeyNmra9pqnHhGfGehw8eLDh5uZmFCtWzNi9e7fVsgULFhj16tUzHj9+HO3x8mU4xlLTZqpp6tF2P//8s1GoUCHDw8PD6NChgzF79mzj+PHjRmRkpNV6VapUMQoXLmwsWrTIuHLlirFmzRrDzc3NWLNmjWEYhrFu3TrDzc3Napvn2+7evWv06tXL+Oijj4zAwEDj1q1bVj8/fvzY6vetLe/N6zwXiE6rVq2Mvn37Wn4ODQ01SpYsaaxevTra9Y8fP24UKlTIWLZsmU39G8bT4+66detibJsyZYpRtGhRo2PHjsapU6eMv//+26hVq5bRunVry3599NFHRq9evYzAwEAjPDzcaNWqleHu7m5s2rTJOHPmjHHnzp2Xvj4vez/Cw8Ot/h0EBAQYn3zyiVGvXj3j3r17UeY9YMAAo2jRooaPj49x7tw548CBA0a5cuUMHx8fwzAM4+HDh0aVKlWM9u3bG6dOnTIOHTpk1KtXz3B3d4/yejyPek689fym1WJCis/zAV9fX6NIkSLGmDFjjPPnzxv/+9//jNKlS1vV27Px7t27Z1SqVMlo3769pf///n5+0Xjh4eHG8ePHDTc3N2Pr1q3G/fv347y/z7c9+/dRt25d488//zQuXrxo9OjRwyhZsqRx//59IyQkxBg9erRRsWJFIzAw0Hj06JExZcoUw83NzRg5cqRx5coV4+LFi8apU6cMDw8PY+bMmcbFixeNQ4cOGc2aNTOaNWtmOYa87PW8ffu2Vf2NHj3a8PLyMk6fPh1l3uvWrTOKFi1qNGvWzDh27Jhx9uxZ45NPPjGqV69uGa9Hjx5GtWrVjL179xpnzpwxevToYbi7u0d5PRzdm1TT1CPi6ty5c4abm5vx008/xbjO5s2bDTc3N+PSpUuW/3fs37/fsvy/bQMGDDDc3NyMuXPnGhcuXDD8/f2j9Pn8Nr/++qvh5uZmbNq0ybK8SpUqxpQpUwzDMIyAgADD29vbGDFihHHu3DnjxIkTRseOHY0qVaoYDx48MO7fv29V/+Hh4fH18piGaQOQIkWKGJ6enpY/hQoVMqpWrWpMnTrVCAsLMwzDMC5dumS4ubkZvr6+Vtv379/fclI9cuRIo169esaNGzcsy/fu3WvcunXLMAzrg3hgYKDh7e1t9OnTxzCMqCfUFStWNBYuXGg11tq1a43ixYsboaGhhmFYF/h/Rfdh8b1794wePXoY3377rXHy5Enj559/NipWrGj079/f5tfL1g/nRo4cabVOqVKljFmzZkW7r89+3rZtm2X91atXG++9957l9TcMw4iIiLDaZ1teo2cuX75seHt7G2PHjo123s8OJs/3FxISYri5uRmbN282DOPp6z1u3Dirfrt165YoP5yjpm2vaeoxYZmxHv/991/jxIkTho+Pj+Hh4WGcPHnSMAzDOHXqlFGyZEnj1KlTUeZjK46x1LTZapp6tN2xY8eM3r17G97e3oabm5vh5uZm1KxZ0zh8+LBlnSpVqhi9evWy2q5+/frGkCFDDMN4+QfGhhH19+mLfrblvXmd5wLRWb9+veHp6Wk8fPjQMAzD2LJli1GiRAnLh6zPO3/+vFG+fHmjefPmxpMnT2wew5YAxN3d3QgKCrIsX7RokVG0aFHLz//9YKlVq1ZGw4YNrfp82etjy/vxvJEjRxrvv/++ce3atWjnPWDAAKNMmTJWr8WoUaOMmjVrWsYuUaKE1Yf3p06divb1+C/qOfHW85tWiwklPs8H+vfvbzRv3txq+eLFi6P9sNgwDGPXrl2Gm5ubsWrVKsMwrOvWlvGi+0DOlv21JQD57bffLMufvUdHjx6NMs9nP7u5uRkhISGWtr59+xpdunSxGufKlSuW+dqyf8/79ddfjSJFilg+jP7vvJ8dU57v77fffjPc3NyMGzduWMbetWuXZXloaKhRrlw5033g/KbVNPWIuDhy5Ijh5uZm/PnnnzGus2fPHsuxz9YApHTp0i8c97/b9OnTx/D29jYCAwMNw7A+35g4caLRoEEDq+0fPnxoeHh4WJ27Jrb/ZycmSV5+jYhjqlq1qvr27SvDMPT3339r1KhRev/999W5c2fLZX6+vr6SpE8++cRq27CwMKVNm1aS1LJlS23btk2VKlVS4cKFVa5cOdWtWzfa+89myZJFgwYNUr9+/VS7dm2re/7duXNHAQEBmjBhgiZPnmxpj4yM1OPHj3Xt2jUVLFgw1vs5duxYBQcHa8qUKZKkokWLKl26dGrbtq3atm2rwoULx7rPmPx3fmnSpFFYWNgLt3n+GQ++vr4KDg5W6dKlrdZ5/Pixzp8/H6vXKDg4WB07dlTp0qX15Zdf2jzvZ+9JWFiY7t69Kz8/P3l6elqtX6pUKUttJCbU9KvXNPUYf8xWj89uDzRq1CgdP35cy5Yt09ChQ9W3b1916dJFhQoViuMrZTuOsfZFTb866jEqT09PeXp6KjIyUqdPn9bOnTu1bNkydejQQb/99pulLv77TKx06dLp8ePHCTKnl703/2WPc4EPPvhAw4cP1/bt21WvXj1t2rRJ1atXV+rUqa3WO3r0qLp27ars2bNr1qxZSpo0aazHepHMmTMrXbp0lp9tOS7nzZvX8ndbXp/YvB/Lly/XqlWrtGTJEuXKlSvGOeTJk8fqtXh+3r6+vsqfP7/Sp09vWV6oUCGb7lVOPTtWPZu5FhNSfJ0P+Pr66v3337da/t/X9nkVKlRQs2bNNGbMGJUvX95qmS3jJaTnbwnzrG5fdCzMlCmT1fvo6+ury5cvy8vLK8q6z84JJNv278SJE+rXr5/69eunypUrv3DeMZ0TPHs9n59P8uTJ5eHh8cL+HNWbXtPUI17m2bOz7t27F+M6z24BGpvnDz7/e9gWgwcPVr169TRkyBDNmDHDapmvr6/+/fffKHUb0/kOojJtAOLq6moptnz58ilr1qxq166d1X3VjP97QMzy5cvl6upqtb2zs7Nl219//VUHDx7U3r179ccff2ju3Ln67rvv1KhRoyjjNmjQQFu3btWQIUP0zTffWNqf3Vt14MCBUX5pSFKOHDnitJ9HjhyJcqB99qyES5cuxfnD4vDw8ChtyZIli9JmvOQhO8mTJ7f8PTIyUvnz59fMmTOjrJcqVSqbX6OwsDB1795dKVOm1Pfffy8nJ6cXziGmeT/7Zf+yfUgsqOlXq2mJeoxPZqjHO3fuaN++ffrggw8sr7+zs7PefvttBQYG6vjx4/r33381bdo0TZ8+XdLT9zs8PFxeXl6aO3euSpUqFavX7RmOsYkPNf1qNS1Rj88LCAjQ7Nmz1alTJ2XPnl3Ozs4qUqSIihQpourVq6tevXo6dOiQatWqJUlycXGJdt4xefY8hbh42XsTndd9LpAqVSrVqlVLmzdvVvny5bV7927NmTPHap1ff/1Vffv2VYkSJTRjxoxX/tDU1uPyyzz/AGhbXh9b349du3bp22+/1ejRo6MEebGZt4uLi9UzH2xBPT/lSPUsmbMWX4f4Oh+Iy/75+Pho7969Gjx4sNWHXLaMF1/i4xz1+dqTntZf/fr11blz5yjrZsyYUbt375b08v27fv26unTpogYNGqht27Yv3I8XzfvZMSox1l9CeNNrmnrEy+TJk0dZsmTRoUOHVLNmzWjXOXjwoLJkyaLcuXNH+2yb6M5l/lt7L5MhQwYNGzZM3bp108aNG62WRUZGqkyZMhoyZEiU7ez9xQFH8cY8BL1MmTJq166dVq5cqV27dkmS3nnnHUlPH9SXN29ey5/169dbHry2ZMkS/frrrypXrpz69++vzZs3q2zZstqyZUuMYw0bNkzh4eEaN26cpS1TpkzKmDGjrl69ajXWP//8o0mTJsV5v7Jly6YzZ85YtT37OX/+/Db1kTRpUj148MCq7fLly3GeU0zc3Nzk7++vNGnSWPY/Z86cGj9+vA4dOmTza/TNN9/o4sWLmjlzZoz/sbFFmjRplCtXLv31119W7f/9ObGipl8N9Ri/HLEeb926pT59+mjfvn2WtmffwilYsKA8PDz066+/auPGjdqwYYM2bNigjz/+WFmzZtWGDRtUrFgxm14bjrF/WbVT01E5Wk3b4k2vx2TJkmnNmjWWBw8/79m3BzNnzmxTX8++Pf38wzn/+4Dn2HjZexOT13kuIElNmjTR3r17tWHDBmXOnFllypSxLPv999/Vu3dvVa5cWfPnz4/Tf/ySJk1q9ZomxHHZltfHlvfjzJkz6t27tzp27Kj69eu/0pwKFSqky5cvKygoyNJ2/vz5F37rkXpO/PX8MmapRXuI6/lAoUKF9Pfff1v1dezYsReOlTp1ao0cOVJ79+61+vdmy3gv+4JAdP57HIyMjNTVq1dj3c/LvPPOOzp37pzV3MPDw/Xdd9/p+vXrNu3f/fv31alTJxUsWNAquIwLd3d3OTk5WZ0DPHnyRP/8888r9esozFzTtqAe8V8uLi5q27at1q5dG+3VFP/++682bNigVq1aycXFJd7PZZ5XvXp11a9fX6NGjbLq/5133tH58+eVI0cOS02mS5dO3377rc6ePSsp4f7NmMUbE4BIUq9evZQvXz4NHTpUDx480DvvvKMqVapoyJAh+v3333X16lXNnTtXs2fPVp48eSQ9/Tbls0uW/fz8tHv3bp06dSray+WeyZw5s77++mtduXLF0ubk5KQOHTpo6dKlWrZsma5cuaLffvtNQ4cOVYoUKSxpsKurqy5duqRbt27ZtE9t27bV7t27NWnSJF25ckX79u3TwIEDVblyZcvtLe7du2e5jC86np6eCgoK0vz583Xt2jX98MMPll+E8alBgwZKly6devbsqePHj+v8+fPy8fHRrl27LAf9l71Gs2fP1pYtWzRu3DglTZpUN2/etPyJy7fHOnTooGXLlmn9+vW6fPmy5s+fr61bt8b7vicUajruqMf452j16ObmpooVK2rkyJE6dOiQzp49Kx8fH4WEhKht27ZKkSKF1Unvs5OMJEmSKG/evJZvdHCMjRk1bc6atsWbXo8ZM2bU559/rsmTJ2vixIk6deqUrl69qh07dqh79+567733bL7axtPTU05OTpo6daquXbumn3/+WT/++GOc5/ay9yYmr/NcQHp6e7IcOXJoypQp+vDDDy3fugwODtaAAQNUtGhRDRo0SMHBwZa6ePZBakREhG7evKnQ0NAY+/f09NSaNWt06tQp+fr6aujQoXG64uNFbHl9XvZ+3Lx5U507d1bZsmXVunVrq38HcfmguF69esqQIYP69u2r06dP66+//lK/fv0s840O9Zz46/llzFKL9hKX84H27dvrxIkTGjdunC5evKjffvvNcovfF+1fuXLl9NFHH1nVpi3jPfuSwNmzZy3vx507d1743nh6emrv3r3atWuXLl++rBEjRigkJOTVXqxotG/fXr6+vho2bJjOnz+vY8eO6csvv9SlS5eUL1++l+5fRESEevfurcePH2vkyJEKCgqy1F5czlfeeust1a5dWyNGjNC+fft07tw5DRo0SAEBAYmu9hKKWWvaFtQjotO+fXtVrFhRLVu21PLly3X58mVdvnxZy5cvV6tWrVSmTBl16NBBkpQ1a1blypVLixcv1vnz53XkyBFNnjw53t6vwYMHK1myZJbbbklPb8l27949y+/M06dPq3fv3jpx4oTc3NwkPf03ExwcrIsXL770lq1vItPeAis6yZMn14gRI9SmTRtNnDhRgwcP1sSJEzVx4kR98803Cg4OVp48eTRq1CjLbSq6d++usLAwjRw5Ujdv3lSWLFnUokULderU6YVj1atXT1u3btWvv/5qaWvfvr2SJ0+upUuXavTo0cqcObOaN2+unj17WtZp3bq1xowZo3///Tfab1n9V4UKFTR79mxNnz5dixcvVoYMGVSjRg316tXLss6oUaN08OBB/f7779H2UaZMGfXo0UMLFizQlClTVLFiRfXs2VNLlix56fixkSZNGi1btkzff/+9PvvsM0VERKho0aJasGCB5X6IL3uNVq1apdDQUH366adR+t++fXus59SiRQsFBwdr0qRJunv3rry9vdWoUSMdOXLk1Xb2NaGmo69pW1CP8c8R63HChAkaP368evfurXv37qlUqVJavny5cubMafN+c4yNGTVtzpq2BfUoffHFF8qXL59Wr16t5cuXKzQ0VDlz5lTt2rVfWg/Pe+uttzRs2DDNnj1bK1as0Lvvvqv+/ftrwIABcZqXLe9NTF7XucAzjRo10uTJk9W4cWNL265duxQSEqLjx4+rYsWKVut7e3tr6dKlun79uqpVq6bvvvvOatvnDR06VEOHDlXz5s2VNWtW9erVSwEBATbPzVYve31e9n6sX79e/v7+8vf312+//WbVd6NGjTR69OhYzSdZsmSaN2+ehg8frubNmytdunTq3Lmz/vnnnxc+c4J6Ttz1bAuz1KI9xOV8wM3NTdOmTdOECRO0aNEi5c+fX61atdLUqVNfun/9+/fXnj17rNpeNl6GDBnUpEkTff/997p8+bIGDx6spk2bytvbO8b3pn379rpy5Yp69eqlZMmSqWnTpqpbt2683y7S09NT8+bN0+TJk9WoUSOlSpVKZcuW1YABAyzB4ov279q1a5YvD1WvXt2q71y5csXpfGXEiBEaOXKkevToIcMwVL9+fXl5eSW62ksoZq1pW1CPiI6zs7MmT56sDRs2aNWqVZo4caIMw9A777yjvn37qmnTppaAw8nJSd9//72+/fZbffjhh8qbN68GDhyojh07xstc0qdPr2HDhqlr166WtrfeekvLli3T+PHj1aJFC7m4uKhkyZJasmSJ5bkkNWvW1OrVq9WgQQMtW7bMcit5POVkOMrNuRFnERER+vjjj7VmzRp7TyXR2bVrl95++22rD4aefRts8eLFdpwZXsSsNU09Oiaz1mN8oKYdk1lrmnp8s8ybN085c+ZUnTp17D2VROXatWu6dOmS1QNpb9y4oYoVK2r58uWv9BwgJBwz1rPZa/Hvv/9WkiRJVKRIEUvb5s2b9dVXX+nYsWOWZ1Ml9BzWrVunYcOGJfhYjuTx48favXu3ypQpY3mouyR98MEHatCggbp162bH2SVe1HTCoB6B1+ONugXWm2revHkxPsjnTbdx40Z17dpVf/31l/z8/LRhwwZt2rRJH374ob2nhhcwa01Tj47JrPUYH6hpx2TWmqYe3xz379/Xli1bVLZsWXtPJdF5/PixOnbsqPnz5+vq1avy9fXV119/rXz58vFNwUTKrPVs9lo8deqU2rRpo+3bt8vf31/79u3T1KlTVbdu3dfyQbEkzZw5U/Xq1XstYzmSZMmSadiwYRoyZIjOnz+vS5cuady4cfL391etWrXsPb1Ei5pOGNQj8HpwBcgb4MmTJ/F+T2OzCAoK0ujRo7V7926FhIQob968at26tT766CN7Tw0vYNaaph4dk1nrMT5Q047JrDVNPdrfsWPH1L59+xeu88EHH7zSrS2eMWsdx4dffvlFs2bN0sWLF5UiRQqVLVtW/fv3j9Wt8kA9xwcz16JhGJo+fbp+/PFH3bhxQ5kyZVLdunXVs2dPyzO3EppZ6yY+nDp1SmPHjtXff/+tiIgIFSlSRF988YVKly5t76klWtR0wqEegYRHAAIAAAAgwT1+/Pilz9lwdXVV5syZX9OMgLijngEAABwDAQgAAAAAAAAAADAdngECAAAAAAAAAABMhwAEAAAAAAAAAACYDgEIAAAAAAAAAAAwHQIQAAAAAAAAAABgOgQgAAAAAAAAAADAdAhAAAAAAAAAAACA6RCAAAAAAAAAAAAA0yEAAQAAAAAAAAAApvP/AGZ3axpebBoLAAAAAElFTkSuQmCC",
      "text/plain": [
       "<Figure size 2000x500 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "percentage_accuracy.append(74.33)\n",
    "labels = [\"ResNet18, unfreezing\", \"ResNet18, freezing\", \"ResNet34, unfreezing\", \"ResNet34, freezing\", \"ShuffleNet_v2, unfreezing\",\n",
    "          \"ShuffleNet_v2, freezing\", \"RegNet, unfreezing\", \"RegNet, freezing\", \"Our Net\"]\n",
    "sns.set_theme(rc={'figure.figsize': (20, 5)})\n",
    "ax = sns.barplot(x=labels, y=percentage_accuracy)\n",
    "for i in ax.containers:\n",
    "    ax.bar_label(i,)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Выбор лучшей модели из представленных"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best accuracy = 92.25 in the model: RegNet, unfreezing\n",
      "Number of epochs = 2, Learning rate = 0.001 with batch size = 128\n"
     ]
    }
   ],
   "source": [
    "best_accuracy = max(percentage_accuracy)\n",
    "index_max = max(range(len(percentage_accuracy)), key=percentage_accuracy.__getitem__)\n",
    "best_model = labels[index_max]\n",
    "print(f'Best accuracy = {best_accuracy} in the model: {best_model}')\n",
    "print(f'Number of epochs = {num_epochs}, Learning rate = {learning_rate} with batch size = {size_of_set}')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
